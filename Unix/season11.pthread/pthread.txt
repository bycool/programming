线程:
	11.1 引言
	多个控制线程在单进程环境中执行多个任务.一个进程中的所有线程都可以访问该进程的组成部件,如文件描述符和内存.无论何时,只要单个资源需要在多个用户空间共享,就必须处理一致性问题.

	11.2 线程概念
	典型的unix进程可以看成只有一个控制的线程:一个进程在同一时刻只做一件事情.
	有了多线程后,在进程设计时可以把进程设计成在同一时刻能够做不止一件事,每个线程处理各自独立的任务.
	这样方法有很多好处:
	.通过为每种时间类型的处理分配单独的线程,能够简化处理异步事件代码.
	.多个线程自动地访问相同的存储地址空间和文件描述符.
	.有些问题可以通过将其分解从而改善整个程序的吞吐量.
	.交互的程序同样可以使用多线程相应时间的改善,多线程可以把程序中处理用户输入输出的部分与其他部分分开.
	线程包含了表示进程内执行环境必须信息,其中包含进程中表示线程的线程ID.一组寄存器值,栈,调度优先级和测略,信号屏蔽字,errno变量以及线程似有数据.进程所有信息对该进程的所有线程都是共享,包括可执行的程序文本,程序的全局内存和堆内存,栈以及文件描述符.

	11.3 线程标识
	就像每个进程有一个进程ID一样的,每个线程也有一个线程ID.线程ID在这个系统是唯一的,但线程ID不同,线程ID只在它所属的进程环境中有效.
	进程ID用pid_t数据类型表示,是一个非负整数.线程ID则用pthread_t数据类型来表示,实现的时候可以用一个结构来代表pthread_t数据类型,所以可移植的操作系统实现不能把它作为整数处理.因此必须使用函数来对两个线程的ID进程比较:
	#include <pthread.h>
	int pthread_equal(pthread_t tid1,pthread_t pid2)
	返回值:若相等返回非0的值,否则返回0

	线程可以通过调用pthread_self(void)函数获得自身的线程ID:
	#include <pthread.h>
	ptread_t pthread_self(void);
	返回值:调用线程的进程ID

	11.4 线程的创建
	程序开始运行时,是以单进程中的单个控制线程启动的,在创建多个控制线程以前,程序的行为与传统的进程并没有什么区别,新增线程可以通过pthread_create函数创建.
	#include <pthread.h>
	int pthread_create(pthread_t *restrict tidp,const pthread_attr_t *restrict attr, void* (*start_rtn)(void),void* restrict arg);
	返回值:成功返回0,不成功返回错误编号
	参数:tidp:当pthread_create成功返回时,由tidp指向的内存单元被设置为新创建线程的线程ID.
		 attr参数用于定制各种不同的线程属性.设置为NULL,创建默认属性的线程.
		 start_rtn:新建线程从start_rtn函数地址开始运行,该函数只有一个无类型指针参数arg,如果参数不止一个,需要把参数放到一个结构体中,然后把这个结构的地址传入.

	11.5 线程终止
	如果进程中的任一线程调用了exit,_Exit或者_exit,那么整个进程会终止.如果信号的默认动作是终止线程,那么,把该信号发送到线程会终止整个进程.
	单个线程可以通过下列三种方式退出,在不终止整个进程的情况下停止它的控制流.
		1.线程只是从启动例程中返回,返回值是线程的退出码.
		2.线程可以被同一进程中的其他线程取消.
		3.线程调用pthread_exit.
	#include <pthread.h>
	void pthread_exit(void *rval_ptr);
	rval_ptr是一个无类型的指针,与传给启动例程的单个参数类似.进程中其他线程可以通过pthread_jion函数访问到这个指针.
	#include <pthread.h>
	int pthread_join(pthread_t thread, void *8rval_ptr);	
	返回值:若成功返回0,失败返回错误编号.

	线程可以调用pthread_cancel函数来请求取消同一进程中的其他线程.
	#include <pthread.h>
	int pthread_cancel(pthread_t tid);
	返回值:如果成功返回0,否则返回错误编码
	默认情况下,pthread_cancel函数会使得有tid表示的线程的行为表现为如同调用了参数为PTHREAD_CANCELED的pthread_exit函数.但是线程可以忽略取消方式或控制取消方式.(调用pthread_cancel(tid)就像在tid线程内调用pthread_exit(PTHREAD_CANCEL)一样的效果.)

	线程可以安排它退出时需要调用的函数,想进程的atexit函数.这种函数成为线程清理处理程序.线程可以创建多个清理处理程序.
	处理程序记录在栈中,他们的执行顺序与他们注册时的顺序相反:
	#include <pthread.h>
	void pthread_cleanup_push(void (*rtn)(void*),void *arg);
	void pthread_cleanup_pop(int execute);  两个函数配对使用.
	当发生以下动作时调用清理函数,调用参数为arg,清理函数rtn的调用顺序有pthread_cleanup_push函数来安排:
	.调用pthread_exit时.
	.相应取消请求时.
	.用非零execute参数调用pthread_cleanup_poo时.
	如果execute参数为0,清理函数将不被调用. 
	PS:两个函数配对使用,在线程执行的函数里调用,设置一个清理函数压栈,之后在出栈执行.当然也可以不执行.pop函数传0即可.

	进程原语和线程原语的比较:
	进程		进程		 		描述
	fork		pthread_cereate		创建新的控制流
	exit		pthread_exit		从现有的控制流中退出
	waitpid		pthread_join		从控制流中获得退出状态
	atexit		pthread_cancel_push	注册退出控制流时调用的函数
	getpid		pthread_self		获得控制流id
	abort		pthread_cancel		请求控制流的非正常退出.


















