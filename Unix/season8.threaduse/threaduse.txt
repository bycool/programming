进行控制：
	8.1 进程控制包括创建进程，执行程序和集成终止。
	8.2 每个进程都有一个非负整数型表示的唯一进程ID。因为进程ID标识符总是唯一的，常将其用作其他标识符的一部分以保证其唯一性。虽然唯一，但是进程ID可以重用。到那个一个进程终止后，其进程ID就可以再次使用了。大多数UNIX系统实现延迟重用算法，使得赋予新进程的ID不同于最近终止进程所使用的ID，防止新进程误入是使用同一ID的某个已终止的先前进程。
	ID为0的进程通常是调度进程。
	ID为1的进程通常是init进程。
	#include <unistd.h>
	pid_t getpid(void)  //返回值：调用进程的进程ID
	pid_t getppid(void) //返回值：调用进程的父进程ID
	uid_t getuid(void)	//调用进程的实际用户ID
	uid_t geteuid(void)	//调用进程的有效用户ID
	gid_t getgid(void)	//调用进程的实际组ID
	gid_t getegid(void)	//调用进程的有效组ID

	8.3 fork函数
	#include <unistd.h>
	pid_t fork(void)	子进程中返回0,父进程中返回进程ID，出错返回-1

	8.4 vfork函数
	pid_t vfork(void)	和fork相同，但语义不同：vfork用于创建一个新进程，而该新进程的目的是exec一个新进程。
	8.5 exit函数
	#include <stdlib.h>
	exit();
	
	8.6 wait和waitpid函数
	当一个进程正常或异常终止时，内核就向其父进程发送SIGCHLD信号。因为子进程终止是个异步事件，所以这种信号也是内核向父进程发的异步通知。父进程可以选择忽略这个信号，或者提供一个该信号发生时即被调用执行的函数。
	现在需要知道的是调用wait或者waitpid的进程可能发现什么情况：
	.如果其所有子进程都还在运行，则阻塞。
	.如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回。
	.如果它没有任何子进程，则立即出错返回。
	如果进程由于接收到SIGCHLD信号而调用wait，则可期望wait会立即返回。但是如果在任意时刻调用wait，则进程可能会阻塞。
	#include <sys/wait.h>
	pid_t wait(int *statloc)
	pid_t waitpid(pid_t pid, int *statloc, int options);
	两个函数返回值：若成功则返回进程ID，0,若出错返回-1
	










































































