高级IO
	14.1 引言
	本章内容包括 非阻塞IO,记录锁,系统V流机制,IO多路转接,readv和writev函数,以及存储映射IO.

	14.2 非阻塞IO
	系统调用分成"低速"系统调用和其他系统调用两类.低速系统调用是可能会使进程永远阻塞的一类调用:
	 .如果某些文件类型(例如管道,终端设备,网络设备)的数据并不存在,则读操作可能会使调用者永远阻塞.
	 .如果数据不能立即被上述相同类型文件接受(管道中无空间,网络流控制等),则写操作也会使调用者永远阻塞.
	 .在某些条件发生之前,打开某些类型的文件会被阻塞.(打开一个终端设备,可能需要等到等到与之连接的调制解调器应答.)
	 .对已经加上强制性记录锁的文件进行读写.
	 .某些ioctl操作.
	 .某些进程间通信函数.

	对于一个给定的描述符有两种方法对其指定的非阻塞IO.
	1,如果调用open获得描述符,则可指定O_NONBLOCK标志.
	2,对于已经打开的一个描述符,则可调用fcntl,由该函数打开O_NONBLOCK文件状态.

	14.4 记录锁
	记录锁的功能是:当一个进程正在读或者修改文件的某一个部分时,它可以阻止其他进程修改同一文件区.
	记录锁其实是:字节范围锁,因为它锁定的只是文件中的一个区域,也可能是整个文件.
	 1,fcntl记录锁
	 SVR3通过fcntl函数增加了记录锁功能,fcntl函数的原型已经给出,这边可以重复一次.
	 #include <fcntl.h>
	 int fcntl(int filedes,int cmd,.../*struct flock *flockptr */);
	 对于记录锁,cmd是F_GETLK,F_SETLK或F_SETLKW. 第三个参数是一个指向flock结构的指针.

	struct flock{
		short l_type;	//F_RDLCK,F_WRLCK,F_UNLCK 指定锁类型.
		off_t l_start;	//相对偏移量:从指定位置偏移的字节数
		short l_whence;	//SEEK_SET,SEEK_CUR,SEEK_END 决定偏移量的起始位置.
		off_t l_len;	//如果为0,表示锁的区域从起点开始直到最大可能偏移量为止.
		pid_t l_pid;	//returned with F_GETLK
	}

	以下说明fcntl函数的三种命令:
	1.F_GETLK: 判断由flockptr所描述的锁是否会被另一把锁排斥.
		如果存在一把锁，它阻止创建由flockptr所描述的锁,则把该现存锁的信息写到flockptr指向的结构中,
		如果不存在这中情况，则除了将l_type设置为UNLCK之外，flockptr所指向结构的其他信息保持不变。
	2.F_SETLK：设置由flockptr所描述的锁，如果试图建立一把锁（读锁或者写锁），而按上述兼容性规则不能允许，则fcntl立即
出错返回，此时errno设置为EACCES或EAGAIN。此命令也用来消除由flockptr说明的锁(l_type为UNLOCK)
	3.F_SETLKW：这是F_SETLK的阻塞版本，如果因为当前在所请求区间的某个部分另一个进程已经有一把锁，因而按兼容性规则由flockptr所请求的锁不能被创建，则使调用进程休眠，如果请求创建的锁已经可用或者休眠由信号终端，则该进程被唤醒。


