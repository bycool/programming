R-B Tree:全称red-black tree, 又称红黑树. 它是一种特殊的二叉查找树。
特性：
	1,每个节点或者是黑色，或者是红色。
	2,根节点是黑色的。
	3,每个叶子节点（NIL）是黑色的。[这里说的叶子节点指的是NIL或NULL的节点。]
	4,如果一个节点是红色的，那么它的叶子节点必须是黑色的。
	5,从一个节点到该节点的子孙节点的所有路径上包含相同的黑节点。

红黑树的基本操作：
	红黑树的基本操作是添加，删除。在对红黑树进行添加或删除后，都会用旋转方法。旋转的目的是让树保持红黑树的特性。
	旋转包括：左旋，右旋。旋转依然保持二叉查找树的有序性。

1,左旋:
      |                           |
      x                           y
    /   \      对x进行左旋转    /   \
   a     y                     x     c
        / \                   / \
       b   c                 a   b

红黑树T的x节点进行左旋:
[伪代码]:
base:
	x->left  = a;
	x->right = y;
	y->left  = b;
	y->right = c;
func_left_rotate(T,x):
	x->right = y->right = b;	//x的右孩子指向y的左孩子，即x->right = b。
	y->left  = x;				//y的左孩子指向x。
	p[x] = p[y];				//指向x的链接旋转后指向y。
	if p[x] = nil[T]			//如果x的父节点为空，即x原本为树的root节点
		root[T] = y;       			则y为新的root节点。
	else if p[x]->left = x		//如果x是其父节点的左孩子。
		p[x]->left = y;			    则x的父节点的左孩子指向y。
	else
		p[x]->right = y;		//如果x是其父节点的右孩子，则x父节点的右孩子指向y。
	
2,右旋:
      |	                         |											
      y                          x
    /   \    对y进行左旋转     /   \
   x     c                    a     y
  / \                             /   \
 a   b                           b     c

红黑树T的y节点进行右旋:
[伪代码]:
base:
	x->left  = a;
	x->right = b;
	y->left  = x;
	y->right = c;
func_right_rotate(T,y):
	y->left = x->right;
	x->right = y;
	p[y] = p[x];
	if p[y] = nil[T]
		root[T] = x;
	else if p[y]->left = y
		p[x]->left = x;
	else
		p[x]->right = y;


3,添加:
首先，将红黑树当作一颗二叉查找树，将新节点插入。[插入后树依然为为二叉查找树，键值是有序的。无论左旋还是右旋，它依然是二叉查找树]
然后，将新结点着色为红色。[为什么新节点是红色，看特性5，红色的新节点不违反特性5，可能违反别的，但是这样会让情况变得简单的多]
	对于特性1.不违反
	对于特性2.不违反，根节点依然是黑色的。
	对于特性3.不违反，即使新插入的节点它的叶子也是黑色的。
	对于特性4.可能违反。
	对于特性5.不违反。
最后，通过旋转和着色等方法使二叉书重新成为红黑树。

[伪代码]: 像二叉查找树一样插入z
func_insert(T, z):
	insert(T,z);
	z->left  = NULL;
	z->right = NULL;
	z->coloer= RED;

func_insert_fixup(T,z):
	define y
	while( p[z].color == RED ){					//如果新节点的父节点是红色
		if( p[z] == p[p[z]]->left ){			//	如果z的父节点是z的祖父节点的左孩子
			y = p[p[z]]->right;					//  y指向z的叔叔节点
			if( y.color == RED ){				//  如果z的叔叔节点是红色的。
				p[z].coloer= BLACK;				//    z的父节点变为黑色。
				y.color = BLACK;				//    z的叔叔节点变为黑色。
				p[p[z]].color = RED;			//    z的祖父节点设为红色。
				p[p[z]] = z;					//    将z的祖父节点设为当前节点.
			}
			
		}
	}


















