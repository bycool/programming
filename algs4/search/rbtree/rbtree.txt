R-B Tree:全称red-black tree, 又称红黑树. 它是一种特殊的二叉查找树。
特性：
	1,每个节点或者是黑色，或者是红色。
	2,根节点是黑色的。
	3,每个叶子节点（NIL）是黑色的。[这里说的叶子节点指的是NIL或NULL的节点。]
	4,如果一个节点是红色的，那么它的叶子节点必须是黑色的。
	5,从一个节点到该节点的子孙节点的所有路径上包含相同的黑节点。

红黑树的基本操作：
	红黑树的基本操作是添加，删除。在对红黑树进行添加或删除后，都会用旋转方法。旋转的目的是让树保持红黑树的特性。
	旋转包括：左旋，右旋。旋转依然保持二叉查找树的有序性。

struct node {
	int val;
	struct node *parent;
	struct node *left, *right;
}

1,左旋:
      |                           |
      x                           y
    /   \      对x进行左旋转    /   \
   a     y                     x     c
        / \                   / \
       b   c                 a   b

红黑树T的x节点进行左旋:
[伪代码]:
	node x;
	node y;
	x->right = y;
	y->parent = x;

left-rotate(T, x){
	x->right = y->left;				// y的左孩子变成x的右孩子。
	if(y->left != NULL)				// 如果y的左孩子不是空，则这个孩子的爹变成x.
		y->left->parent = x;
	y->parent = x->parent;			// x的爹变成y的爹
	if(x->parent == NULL)			// x要是没爹，y就是这个树的祖先。
		T.root = y;
	elseif(x == x->parent->left)	// 如果x是它爹的左儿子，那这位父亲的左儿子变成了y
		x->parent->left = y;
	else
		x->parent->right = y;		// 如果x是它爹的右儿子，那么y变成了它右儿子了。
	y->left = x;					// x成为y的左儿子
	x->parent = y;					// x也叫y一声爹
}
	
2,右旋:
      |	                         |											
      y                          x
    /   \    对y进行左旋转     /   \
   x     c                    a     y
  / \                             /   \
 a   b                           b     c

红黑树T的y节点进行右旋:
[伪代码]:
base:
	x->left  = a;
	x->right = b;
	y->left  = x;
	y->right = c;
func_right_rotate(T,y):
	y->left = x->right;
	if(x->right != NULL)
		x->right->parent = y;
	x->parent = y->parent;
	if(y->parent == NULL)
		T.root = x;
	elseif(y == y->parent->left)
		y->parent->left = x;
	else
		y->parent->right = x;
	x->right = y;
	y->parent = x;


3,添加:
首先，将红黑树当作一颗二叉查找树，将新节点插入。[插入后树依然为为二叉查找树，键值是有序的。无论左旋还是右旋，它依然是二叉查找树]
然后，将新结点着色为红色。[为什么新节点是红色，看特性5，红色的新节点不违反特性5，可能违反别的，但是这样会让情况变得简单的多]
	对于特性1.不违反
	对于特性2.不违反，根节点依然是黑色的。
	对于特性3.不违反，即使新插入的节点它的叶子也是黑色的。
	对于特性4.可能违反。
	对于特性5.不违反。
最后，通过旋转和着色等方法使二叉书重新成为红黑树。

[伪代码]: 像二叉查找树一样插入z
func_insert(T, z):
	y = NULL;
	x = T.root;
	while (x != NULL){
		y = x;
		if(z->val < x->val)
			x = x->left;
		else
			x = x->right;
	}
	z->parent = y;
	if(y == NULL)
		T.root = z;
	else if(z->val <  y->val)
		y->left = z;
	else
		y->right = z;
	z->left = NULL;
	z->right = NULL;
	z->color = RED;
	FUNC_INSERT_FIXUP(T,z);		//需要对插入z后的树进行颜色和旋转的调整，使其成为红黑树。

func_insert_fixup(T,z):
	while( p[z].color == RED ){					//如果新节点的父节点是红色
		if( p[z] == p[p[z]]->left ){			//	如果z的父节点是z的祖父节点的左孩子
			y = p[p[z]]->right;					//  y指向z的叔叔节点
			if( y.color == RED ){				//  如果z的叔叔节点是红色的。
				p[z].coloer= BLACK;				//    z的父节点变为黑色。
				y.color = BLACK;				//    z的叔叔节点变为黑色。
				p[p[z]].color = RED;			//    z的祖父节点设为红色。
				z = p[p[z]];					//    将z的祖父节点设为当前节点.
				continue;
			}elseif(z == p[z].right){			//  如果z的叔叔节点是黑色的，且z是右孩子。
				z = p[z]];						//
				right_rotate(T, z);
			}
			left_rotate(T,z);
			p[z].color = BLACK;
			p[p[z]].color = RED;
		}elseif(p[z] == p[p[z]]->right){

		}
	}
	T.root.color = BLACK;


















