1,进程的内存划分方案
	代码段 
		(.text)  : 该段包含了供CPU执行的机器码指令
	数据段
		(.data)  : 初始化数据
		(.bss)   : 未初始化数据
		(.rdata) : 只读数据
	堆: 动态内存分配的区域
	栈: 为每个函数提供独立的存储函数
	最上层部分属于内核区域，特定进程的环境变量就存在该区域


	-------------------------------------
	系统：控制程序执行的操作系统功能     
          -------------------------------
	      环境变量
          argv(命令行参数列表)
          argc(命令行参数个数)
	-------------------------------------
	栈:   main()函数中的局部变量
		  -------------------------------
          其它函数中的局部变量
		  -------------------------------
              。。。。。
	-------------------------------------
	共享内存: 动态链接库函数
	-------------------------------------
	          。。。。。
	堆:       。。。。。
	-------------------------------------
	数据: 初始化数据
	      -------------------------------
		  未初始化数据
    -------------------------------------
    代码: 静态链接库函数
          -------------------------------
		  其它程序函数
		  -------------------------------
		  main()函数(main.o)
		  -------------------------------
		  启动例程(crt0.o)
	------------------------------------- 0x00000000

2, 二进制文件，编译器，链接器与装载器的作用
	程序的二进制文件包含了程序运行中的内存映射布局的细节
	链接器创建二进制文件的整体框架。链接器要对编译器生成的二进制文件进行合并，然后向各个内存映射段填充信息。
	进程内存映射的初始化建立工作是由程序装载器这一系统工具完成。在最简单的情况下，装载器会打开二进制可执行程序，读取节的相关信息，然后将这些信息载入进程内存映射结构里。


3, 程序声明周期阶段接触
	为了完整理解整个生命周期过程。围绕一下几个程序声明周期进行深入讨论
		1) 编写源代码
		2) 编译
		3) 链接
		4) 装载
		5) 执行

	编译阶段:
		1,编译器负责编译程序
			编译的各个阶段
			1,预处理阶段：文本处理过程  gcc -E function.c -o function.i  gcc预处理
				将#include关键字表示的含有定义的文件包含到源文件中.
				将#define语句指定的值转换称常量
				将在代码中调用宏的地方将宏定义转换称代码
				将根据#if,#elif和#endif指令的位置包含或排除特定部分的代码
			2,语言分析阶段
				词法分析:将源代码分割成不可分割的单词
				语法分析:将提取出来的单词链接称单词序列，并根据编程语言规则验证其顺序是否合理
				语义分析:目的是发现符合语法规则的语句是否具有实际意义。
			3,汇编阶段   gcc -S function.c -o function.s  gcc生成汇编文件
			4,优化阶段
				当由源代码生成最初版本的汇编代码后，优化过程就开始了，这可以将程序的寄存器使用率最小化.
			5,代码生成阶段
				
		2,编译器的输入是一个编译单元
		3,一个程序通常包裹几个编译单元
		4,编译过程的输出是一系列二进制目标文件的结合
		5,若像让程序能够执行，这些目标文件还需要经过另一个程序构建阶段的处理: 链接
	
4,使用静态库
	
























































